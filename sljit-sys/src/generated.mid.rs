 
impl Compiler {
    pub fn get_compiler_error(&mut self, ) -> sljit_s32 { unsafe { sljit_get_compiler_error(self.inner, ) } }
    pub fn alloc_memory(&mut self, size: sljit_s32,) -> *mut ::core::ffi::c_void { unsafe { sljit_alloc_memory(self.inner, size,) } }
    pub fn get_allocator_data(&mut self, ) -> *mut ::core::ffi::c_void { unsafe { sljit_get_allocator_data(self.inner, ) } }
    pub fn get_exec_allocator_data(&mut self, ) -> *mut ::core::ffi::c_void { unsafe { sljit_get_exec_allocator_data(self.inner, ) } }
    pub fn get_executable_offset(&mut self, ) -> sljit_sw { unsafe { sljit_get_executable_offset(self.inner, ) } }
    pub fn get_generated_code_size(&mut self, ) -> sljit_uw { unsafe { sljit_get_generated_code_size(self.inner, ) } }
    pub fn emit_enter(&mut self, options: sljit_s32,
    arg_types: sljit_s32,
    scratches: sljit_s32,
    saveds: sljit_s32,
    fscratches: sljit_s32,
    fsaveds: sljit_s32,
    local_size: sljit_s32,) -> sljit_s32 { unsafe { sljit_emit_enter(self.inner, options,
            arg_types,
            scratches,
            saveds,
            fscratches,
            fsaveds,
            local_size,) } }
    pub fn set_context(&mut self, options: sljit_s32,
    arg_types: sljit_s32,
    scratches: sljit_s32,
    saveds: sljit_s32,
    fscratches: sljit_s32,
    fsaveds: sljit_s32,
    local_size: sljit_s32,) -> sljit_s32 { unsafe { sljit_set_context(self.inner, options,
            arg_types,
            scratches,
            saveds,
            fscratches,
            fsaveds,
            local_size,) } }
    pub fn emit_return_void(&mut self, ) -> sljit_s32 { unsafe { sljit_emit_return_void(self.inner, ) } }
    pub fn emit_return(&mut self, op: sljit_s32,
    src: sljit_s32,
    srcw: sljit_sw,) -> sljit_s32 { unsafe { sljit_emit_return(self.inner, op,
            src,
            srcw,) } }
    pub fn emit_return_to(&mut self, src: sljit_s32,
    srcw: sljit_sw,) -> sljit_s32 { unsafe { sljit_emit_return_to(self.inner, src,
            srcw,) } }
    pub fn emit_op0(&mut self, op: sljit_s32) -> sljit_s32 { unsafe { sljit_emit_op0(self.inner, op,) } }
    pub fn emit_op1(&mut self, op: sljit_s32,
    dst: sljit_s32,
    dstw: sljit_sw,
    src: sljit_s32,
    srcw: sljit_sw,) -> sljit_s32 { unsafe { sljit_emit_op1(self.inner, op,
            dst,
            dstw,
            src,
            srcw,) } }
    pub fn emit_op2(&mut self, op: sljit_s32,
    dst: sljit_s32,
    dstw: sljit_sw,
    src1: sljit_s32,
    src1w: sljit_sw,
    src2: sljit_s32,
    src2w: sljit_sw,) -> sljit_s32 { unsafe { sljit_emit_op2(self.inner, op,
            dst,
            dstw,
            src1,
            src1w,
            src2,
            src2w,) } }
    pub fn emit_op2u(&mut self, op: sljit_s32,
    src1: sljit_s32,
    src1w: sljit_sw,
    src2: sljit_s32,
    src2w: sljit_sw,) -> sljit_s32 { unsafe { sljit_emit_op2u(self.inner, op,
            src1,
            src1w,
            src2,
            src2w,) } }
    pub fn emit_shift_into(&mut self, op: sljit_s32,
    dst_reg: sljit_s32,
    src1_reg: sljit_s32,
    src2_reg: sljit_s32,
    src3: sljit_s32,
    src3w: sljit_sw,) -> sljit_s32 { unsafe { sljit_emit_shift_into(self.inner, op,
            dst_reg,
            src1_reg,
            src2_reg,
            src3,
            src3w,) } }
    pub fn emit_op_src(&mut self, op: sljit_s32,
    src: sljit_s32,
    srcw: sljit_sw,) -> sljit_s32 { unsafe { sljit_emit_op_src(self.inner, op,
            src,
            srcw,) } }
    pub fn emit_op_dst(&mut self, op: sljit_s32,
    dst: sljit_s32,
    dstw: sljit_sw,) -> sljit_s32 { unsafe { sljit_emit_op_dst(self.inner, op,
            dst,
            dstw,) } }
    pub fn emit_fop1(&mut self, op: sljit_s32,
    dst: sljit_s32,
    dstw: sljit_sw,
    src: sljit_s32,
    srcw: sljit_sw,) -> sljit_s32 { unsafe { sljit_emit_fop1(self.inner, op,
            dst,
            dstw,
            src,
            srcw,) } }
    pub fn emit_fop2(&mut self, op: sljit_s32,
    dst: sljit_s32,
    dstw: sljit_sw,
    src1: sljit_s32,
    src1w: sljit_sw,
    src2: sljit_s32,
    src2w: sljit_sw,) -> sljit_s32 { unsafe { sljit_emit_fop2(self.inner, op,
            dst,
            dstw,
            src1,
            src1w,
            src2,
            src2w,) } }
    pub fn emit_fop2r(&mut self, op: sljit_s32,
    dst_freg: sljit_s32,
    src1: sljit_s32,
    src1w: sljit_sw,
    src2: sljit_s32,
    src2w: sljit_sw,) -> sljit_s32 { unsafe { sljit_emit_fop2r(self.inner, op,
            dst_freg,
            src1,
            src1w,
            src2,
            src2w,) } }
    pub fn emit_fset32(&mut self, freg: sljit_s32,
    value: sljit_f32,) -> sljit_s32 { unsafe { sljit_emit_fset32(self.inner, freg,
            value,) } }
    pub fn emit_fset64(&mut self, freg: sljit_s32,
    value: sljit_f64,) -> sljit_s32 { unsafe { sljit_emit_fset64(self.inner, freg,
            value,) } }
    pub fn emit_fcopy(&mut self, op: sljit_s32,
    freg: sljit_s32,
    reg: sljit_s32,) -> sljit_s32 { unsafe { sljit_emit_fcopy(self.inner, op,
            freg,
            reg,) } }
    pub fn emit_ijump(&mut self, type_: sljit_s32,
    src: sljit_s32,
    srcw: sljit_sw,) -> sljit_s32 { unsafe { sljit_emit_ijump(self.inner, type_,
            src,
            srcw,) } }
    pub fn emit_icall(&mut self, type_: sljit_s32,
    arg_types: sljit_s32,
    src: sljit_s32,
    srcw: sljit_sw,) -> sljit_s32 { unsafe { sljit_emit_icall(self.inner, type_,
            arg_types,
            src,
            srcw,) } }
    pub fn emit_op_flags(&mut self, op: sljit_s32,
    dst: sljit_s32,
    dstw: sljit_sw,
    type_: sljit_s32,) -> sljit_s32 { unsafe { sljit_emit_op_flags(self.inner, op,
            dst,
            dstw,
            type_,) } }
    pub fn emit_select(&mut self, type_: sljit_s32,
    dst_reg: sljit_s32,
    src1: sljit_s32,
    src1w: sljit_sw,
    src2_reg: sljit_s32,) -> sljit_s32 { unsafe { sljit_emit_select(self.inner, type_,
            dst_reg,
            src1,
            src1w,
            src2_reg,) } }
    pub fn emit_fselect(&mut self, type_: sljit_s32,
    dst_freg: sljit_s32,
    src1: sljit_s32,
    src1w: sljit_sw,
    src2_freg: sljit_s32,) -> sljit_s32 { unsafe { sljit_emit_fselect(self.inner, type_,
            dst_freg,
            src1,
            src1w,
            src2_freg,) } }
    pub fn emit_mem(&mut self, type_: sljit_s32,
    reg: sljit_s32,
    mem: sljit_s32,
    memw: sljit_sw,) -> sljit_s32 { unsafe { sljit_emit_mem(self.inner, type_,
            reg,
            mem,
            memw,) } }
    pub fn emit_mem_update(&mut self, type_: sljit_s32,
    reg: sljit_s32,
    mem: sljit_s32,
    memw: sljit_sw,) -> sljit_s32 { unsafe { sljit_emit_mem_update(self.inner, type_,
            reg,
            mem,
            memw,) } }
    pub fn emit_fmem(&mut self, type_: sljit_s32,
    freg: sljit_s32,
    mem: sljit_s32,
    memw: sljit_sw,) -> sljit_s32 { unsafe { sljit_emit_fmem(self.inner, type_,
            freg,
            mem,
            memw,) } }
    pub fn emit_fmem_update(&mut self, type_: sljit_s32,
    freg: sljit_s32,
    mem: sljit_s32,
    memw: sljit_sw,) -> sljit_s32 { unsafe { sljit_emit_fmem_update(self.inner, type_,
            freg,
            mem,
            memw,) } }
    pub fn emit_simd_mov(&mut self, type_: sljit_s32,
    freg: sljit_s32,
    srcdst: sljit_s32,
    srcdstw: sljit_sw,) -> sljit_s32 { unsafe { sljit_emit_simd_mov(self.inner, type_,
            freg,
            srcdst,
            srcdstw,) } }
    pub fn emit_simd_replicate(&mut self, type_: sljit_s32,
    freg: sljit_s32,
    src: sljit_s32,
    srcw: sljit_sw,) -> sljit_s32 { unsafe { sljit_emit_simd_replicate(self.inner, type_,
            freg,
            src,
            srcw,) } }
    pub fn emit_simd_lane_mov(&mut self, type_: sljit_s32,
    freg: sljit_s32,
    lane_index: sljit_s32,
    srcdst: sljit_s32,
    srcdstw: sljit_sw,) -> sljit_s32 { unsafe { sljit_emit_simd_lane_mov(self.inner, type_,
            freg,
            lane_index,
            srcdst,
            srcdstw,) } }
    pub fn emit_simd_lane_replicate(&mut self, type_: sljit_s32,
    freg: sljit_s32,
    src: sljit_s32,
    src_lane_index: sljit_s32,) -> sljit_s32 { unsafe { sljit_emit_simd_lane_replicate(self.inner, type_,
            freg,
            src,
            src_lane_index,) } }
    pub fn emit_simd_extend(&mut self, type_: sljit_s32,
    freg: sljit_s32,
    src: sljit_s32,
    srcw: sljit_sw,) -> sljit_s32 { unsafe { sljit_emit_simd_extend(self.inner, type_,
            freg,
            src,
            srcw,) } }
    pub fn emit_simd_sign(&mut self, type_: sljit_s32,
    freg: sljit_s32,
    dst: sljit_s32,
    dstw: sljit_sw,) -> sljit_s32 { unsafe { sljit_emit_simd_sign(self.inner, type_,
            freg,
            dst,
            dstw,) } }
    pub fn emit_simd_op2(&mut self, type_: sljit_s32,
    dst_freg: sljit_s32,
    src1_freg: sljit_s32,
    src2_freg: sljit_s32,) -> sljit_s32 { unsafe { sljit_emit_simd_op2(self.inner, type_,
            dst_freg,
            src1_freg,
            src2_freg,) } }
    pub fn emit_atomic_load(&mut self, op: sljit_s32,
    dst_reg: sljit_s32,
    mem_reg: sljit_s32,) -> sljit_s32 { unsafe { sljit_emit_atomic_load(self.inner, op,
            dst_reg,
            mem_reg,) } }
    pub fn emit_atomic_store(&mut self, op: sljit_s32,
    src_reg: sljit_s32,
    mem_reg: sljit_s32,
    temp_reg: sljit_s32,) -> sljit_s32 { unsafe { sljit_emit_atomic_store(self.inner, op,
            src_reg,
            mem_reg,
            temp_reg,) } }
    pub fn get_local_base(&mut self, dst: sljit_s32,
    dstw: sljit_sw,
    offset: sljit_sw,) -> sljit_s32 { unsafe { sljit_get_local_base(self.inner, dst,
            dstw,
            offset,) } }
    pub fn emit_op_custom(&mut self, instruction: *mut ::core::ffi::c_void,
    size: sljit_u32,) -> sljit_s32 { unsafe { sljit_emit_op_custom(self.inner, instruction,
            size,) } }
    pub fn emit_label(&mut self, ) -> Label { unsafe { sljit_emit_label(self.inner, ) }.into() }
    pub fn emit_jump(&mut self, type_: sljit_s32) -> Jump { unsafe { sljit_emit_jump(self.inner, type_,) }.into() }
    pub fn emit_call(&mut self, type_: sljit_s32,
    arg_types: sljit_s32,) -> Jump { unsafe { sljit_emit_call(self.inner, type_,
            arg_types,) }.into() }
    pub fn emit_cmp(&mut self, type_: sljit_s32,
    src1: sljit_s32,
    src1w: sljit_sw,
    src2: sljit_s32,
    src2w: sljit_sw,) -> Jump { unsafe { sljit_emit_cmp(self.inner, type_,
            src1,
            src1w,
            src2,
            src2w,) }.into() }
    pub fn emit_fcmp(&mut self, type_: sljit_s32,
    src1: sljit_s32,
    src1w: sljit_sw,
    src2: sljit_s32,
    src2w: sljit_sw,) -> Jump { unsafe { sljit_emit_fcmp(self.inner, type_,
            src1,
            src1w,
            src2,
            src2w,) }.into() }
    pub fn emit_const(&mut self, dst: sljit_s32,
    dstw: sljit_sw,
    init_value: sljit_sw,) -> Constant { unsafe { sljit_emit_const(self.inner, dst,
            dstw,
            init_value,) }.into() }
    pub fn emit_put_label(&mut self, dst: sljit_s32,
    dstw: sljit_sw,) -> PutLabel { unsafe { sljit_emit_put_label(self.inner, dst,
            dstw,) }.into() }
    pub fn set_compiler_memory_error(&mut self, ) { unsafe { sljit_set_compiler_memory_error(self.inner, ) } }
    pub fn set_current_flags(&mut self, current_flags: sljit_s32) { unsafe { sljit_set_current_flags(self.inner, current_flags,) } }
}
