# vibewasm

<div align="center">

A lightweight WebAssembly JIT compiler built on [SLJIT](https://zherczeg.github.io/sljit/), the platform-independent low-level JIT compiler.

[![Rust](https://img.shields.io/badge/rust-stable-orange.svg)](https://www.rust-lang.org/)
[![License](https://img.shields.io/badge/license-MIT-blue.svg)](../LICENSE)

</div>

---

## Overview

**vibewasm** is an experimental WebAssembly execution engine that compiles WebAssembly bytecode directly to native machine code using SLJIT as its code generation backend. Unlike traditional WebAssembly runtimes that employ complex optimization pipelines (e.g., Cranelift in Wasmtime, LLVM in Wasmer), vibewasm takes a minimalist approach: a single-pass, zero-optimization JIT compiler designed for fast compilation times and a small binary footprint.

### Key Characteristics

- **Single-pass compilation**: WebAssembly operators are translated directly to SLJIT instructions without intermediate representation (IR) or optimization passes
- **Minimal runtime overhead**: No garbage collection, no complex memory management beyond what WebAssembly specifies
- **Cross-platform**: Leverages SLJIT's support for x86/x64, ARM32/64, RISC-V, MIPS, PowerPC, LoongArch, and s390x
- **Small footprint**: Approximately 5,000 lines of Rust code for the complete runtime
- **Vibe coded**: The code is 99% generated by LLM

## Architecture

vibewasm follows a Store-based architecture inspired by [wasmtime](https://github.com/bytecodealliance/wasmtime) and [wasmi](https://github.com/wasmi-labs/wasmi). The design separates concerns between configuration, runtime state management, module representation, and code compilation.

### Runtime Layer

At the core of vibewasm is the **Engine**, which holds compilation configuration and WebAssembly feature flags such as multi-value returns, bulk memory operations, and sign-extension operators. The Engine is stateless and designed to be shared across multiple execution contexts via `Arc<Engine>`, making it suitable for multi-threaded applications where multiple modules need to share the same configuration.

The **Store** serves as the central runtime state container. It owns all runtime resources: linear memories, tables of function references, mutable and immutable globals, and the function registry. When you instantiate a WebAssembly module, the Store allocates the necessary resources and maintains their lifecycle. The Store also holds references to compiled code to prevent them from being deallocated while still in use. Each Store is independent, providing isolation between different execution contexts.

### Module Compilation Pipeline

The **Module** represents a parsed WebAssembly binary. When you create a Module, vibewasm uses the `wasmparser` crate to validate and parse the binary format, extracting type definitions, import and export declarations, function bodies, data segments for memory initialization, and element segments for table initialization. The Module is immutable after creation and can be instantiated multiple times with different import resolutions.

The **Linker** is a helper utility for resolving module imports. Before a module can be instantiated, all its imports must be satisfied. The Linker maintains a registry of named functions, memories, tables, and globals from different namespaces (typically corresponding to different modules). You can register host functions with the Linker to provide native Rust implementations that WebAssembly code can call.

The **Instance** represents a fully instantiated module with all imports resolved. During instantiation, the Linker matches each import declaration in the Module against its registry, compiles all function bodies to native code, initializes memory with data segments, populates tables with element segments, and evaluates global initializers. The Instance then provides access to exported functions and memories for the host application to interact with.

### Compilation Engine

The **Function** compiler is the heart of vibewasm's JIT capability. It translates WebAssembly bytecode operators directly into SLJIT instructions in a single forward pass. The compiler maintains a virtual operand stack that tracks where values reside (in registers, on the memory stack, or as compile-time constants) and generates code to move values between these locations as needed. Each compiled function produces a **GeneratedCode** object containing executable machine code that can be called directly.

### Resource Types

**Memory** implements WebAssembly's linear memory model as a contiguous, byte-addressable array. Memories are allocated in 64KB pages and can grow dynamically up to an optional maximum limit. The memory provides raw pointer access for JIT-compiled code to perform fast loads and stores.

**Table** holds references to functions, enabling indirect calls through `call_indirect`. Tables support the `funcref` type and can be dynamically grown. They are used for implementing function pointers, virtual method dispatch, and computed branches.

**Global** represents a global variable that persists across function calls. Globals can be either mutable or immutable and store any WebAssembly value type (i32, i64, f32, f64, or reference types).

**Func** encapsulates a callable function, which can be either a compiled WebAssembly function or a host-provided function. For host functions, vibewasm generates trampolines using libffi to bridge between the JIT calling convention and Rust's native calling convention.

### Component Reference

| Component | Responsibility |
|-----------|----------------|
| [`Engine`](src/engine.rs) | Holds compilation configuration and WebAssembly feature flags. Stateless and shareable across threads via `Arc<Engine>`. |
| [`Store`](src/store.rs) | Runtime state container that owns all memories, tables, globals, and functions. Manages the lifecycle of compiled code. |
| [`Module`](src/module.rs) | Parsed WebAssembly module. Contains types, imports, exports, function bodies, data segments, and element segments. |
| [`Instance`](src/instance.rs) | Instantiated module with resolved imports. Provides access to exported functions and memories. |
| [`Linker`](src/linker.rs) | Helper for resolving module imports by name. Supports both host functions and wasm-to-wasm linking. |
| [`Function`](src/function.rs) | The core compiler that translates WebAssembly operators to SLJIT instructions. |

## Technical Deep Dive

### SLJIT as Code Generation Backend

[SLJIT](https://github.com/zherczeg/sljit) (Stack-less JIT) is a C library that provides a virtual instruction set abstraction over multiple CPU architectures. Key characteristics relevant to vibewasm:

1. **Word-sized operations**: SLJIT primarily operates on native word-sized values (`isize`/`usize`), not explicit `i32`/`i64` types. This simplifies codegen on 64-bit platforms but requires careful handling on 32-bit systems.

2. **Limited register set**: SLJIT provides 3 scratch registers (R0-R2) and 3 saved registers (S0-S2) for integer operations, plus 2 float registers (FR0-FR1). The compiler must efficiently manage register allocation and spilling.

3. **No built-in calling convention**: SLJIT does not enforce a calling convention beyond its register ABI. vibewasm implements a custom convention for wasm-to-wasm and host function calls.

4. **Platform-specific limitations**: Some operations (e.g., `sqrt`, `ceil`, `floor`) are not available directly in SLJIT and require helper function calls through libm.

### Compilation Strategy

The compiler uses a **stackless emulation** approach:

```
WebAssembly Stack Machine â†’ SLJIT Register Machine + Memory Stack
```

During compilation:

- Parameters (first 3) map to saved registers S0, S1, S2
- Additional parameters and locals are allocated on the SLJIT stack
- WebAssembly operand stack values are tracked as:
  - `Register(ScratchRegister)` - value in a scratch register
  - `FloatRegister(FloatRegister)` - floating-point value
  - `Stack(offset)` - value spilled to stack memory
  - `Const(value)` - compile-time constant
  - `Saved(SavedRegister)` - value in a saved register

When registers are exhausted, values are spilled to the stack. The compiler tracks register occupancy via bitmaps and reallocates registers as needed.

### Calling Convention

All JIT-compiled functions use a uniform signature:

```c
typedef wasm_value (*wasm_func_t)(
    wasm_context *context, // Runtime context pointer
    size_t argc,           // Argument size
    wasm_value *argv       // Argument memory chunk
);
```

For functions with more than 3 parameters, additional arguments are passed on the stack. The compiler generates appropriate prologue/epilogue code to handle this.

For **host function calls**, vibewasm uses [libffi](https://github.com/libffi/libffi) to generate trampolines that:

1. Convert from the JIT calling convention to Rust's calling convention
2. Retrieve the Store pointer from thread-local storage
3. Invoke the host callback
4. Convert the result back to word-sized values

### 32-bit Platform Support

On 32-bit platforms, 64-bit WebAssembly operations require special handling:

- **I64 values**: Stored as (low, high) pairs on the stack
- **I64 arithmetic**: Implemented via helper functions that operate on 64-bit values through memory pointers
- **I64 comparisons**: Similarly delegated to helper functions

This approach, while not optimal for performance, ensures correctness across all supported platforms.

### Memory Access Model

Linear memory access in vibewasm:

- The memory base pointer is passed as the first argument (mapped to S0)
- Load/store operations compute: `effective_address = base + dynamic_offset + static_offset`
- Currently, memory bounds checking is **not** performed for performance reasons (unsafe mode)

## Codegen Design

This section describes the planned code generation architecture that will be implemented in upcoming versions.

### JIT Function Prototype

Each JIT-compiled function will adhere to the following prototype:

```c
typedef wasm_value (*vibewasm_jit_fn_t)(
    wasm_context *ctx,
    size_t argc,
    wasm_value *argv
);
```

**Parameter breakdown:**

- **`wasm_context *ctx`**: Pointer to the [`WasmContext`](src/context.rs) structure containing runtime stateâ€”memory base pointers (with multi-memory support planned), function table references, and pointers to other JIT-compiled functions.

- **`size_t argc`**: The number of arguments being passed. This enables runtime validation and debugging.

- **`wasm_value *argv`**: A pointer to an array of 64-bit aligned memory chunks. `wasm_value` is not a concrete type but rather a conceptual representationâ€”each element occupies 8 bytes to accommodate IEEE 754 double-precision floats and 64-bit integers uniformly.

### Stack and Local Variable Handling

SLJIT provides its own local stack mechanism, but vibewasm takes a deliberate approach to argument passing:

1. **Arguments are not spilled**: Rather than copying `argv` values onto the SLJIT local stack, the compiler generates code that directly accesses `argv` memory locations via pointer arithmetic. This reduces memory traffic and register pressure.

2. **Explicit locals use SLJIT stack**: When a WebAssembly function declares local variables (beyond parameters), these are allocated on SLJIT's stack pointer-relative addressing.

3. **Direct memory access pattern**: For parameter access, the generated code computes `&argv[index]` directly rather than loading into a register first (when possible).

### Operator Mapping

Most WebAssembly unary and binary operations map 1:1 to SLJIT instructions on 64-bit platforms:

| WebAssembly | SLJIT (64-bit) | Notes |
|-------------|----------------|-------|
| `i32.add` | `SLJIT_ADD32` | Direct mapping |
| `i64.add` | `SLJIT_ADD` | Word-sized on 64-bit |
| `f64.mul` | `SLJIT_MUL_F64` | Native float ops |
| `i32.clz` | `SLJIT_CLZ32` | Count leading zeros |

On 32-bit platforms, 64-bit operations require the helper function approach described in the "32-bit Platform Support" section above.

### Function Calling Challenges

WebAssembly functions can theoretically accept an unlimited number of parameters, but SLJIT has architectural constraints:

- **Limited saved registers**: SLJIT provides only up to 7 saved registers across function calls (S0-S6, platform-dependent)
- **No user-controlled stack**: SLJIT does not expose a user-manipulable call stack, preventing standard calling conventions
- **No built-in convention**: Unlike native compilers, we cannot rely on `__fastcall`, `__stdcall`, or `__cdecl`

This means we **cannot** rely on the traditional approach where excess arguments automatically spill to the stack. Instead, vibewasm implements a **universal argument-passing convention** using the `(ctx, argc, argv)` pattern.

**Conceptual call pattern:**

```rust
let ctx: WasmContext = /* ... */;
let ctx_ptr = &ctx as *const WasmContext;
let args = vec![1i64, 2i64, 3i64, 4i64];
let args_ptr = args.as_ptr();
let f: vibewasm_jit_fn_t = func.compile_function();

unsafe {
    (*f)(ctx_ptr, args.len(), args_ptr)
}
```

### Wasm-to-Wasm Call Codegen

Consider this WebAssembly module with nested function calls:

```wat
(module
    ;; Add 1 to the input
    (func $add_one (param i32) (result i32)
        local.get 0
        i32.const 1
        i32.add
    )

    ;; Call add_one twice (adds 2)
    (func $add_two (param i32) (result i32)
        local.get 0
        call $add_one
        call $add_one
    )

    ;; Main function: calls add_two (which calls add_one twice)
    (func (export "test") (param i32) (result i32)
        local.get 0
        call $add_two
    )
)
```

When `test` calls `$add_two`, which in turn calls `$add_one` twice, the generated code must:

1. **Prepare the argument array**: Materialize the operand stack values into a contiguous `argv` buffer
2. **Look up the callee**: Retrieve the function pointer from the context's function table
3. **Execute the call**: Invoke with the standardized `(ctx, argc, argv)` signature
4. **Handle the result**: Push the return value(s) back onto the operand stack

**Current status**: This wasm-to-wasm call codegen requires significant refactoring. The compiler must track the target function's type signature to generate the correct argument array size and layout.

### Host Function Calling

For host functions (Rust callbacks), the challenge is bridging between vibewasm's uniform calling convention and Rust's native calling convention:

```
JIT Code â†’ Trampoline â†’ Host Function (Rust)
```

The trampoline must:

1. **Unpack arguments**: Convert `(argc, argv)` into individual typed parameters
2. **Retrieve context**: Access the [`Store`](src/store.rs) pointer from thread-local storage
3. **Invoke the callback**: Call the Rust closure with proper types
4. **Pack the result**: Convert the return value back into the `wasm_value` format

**Investigation needed**: Whether libffi remains the optimal choice for trampoline generation, or if a custom approach would offer better performance and smaller binary size.

### Implementation Roadmap

The following tasks are planned for the codegen redesign:

- [ ] Implement multi-memory support in `WasmContext`
- [ ] Respect memory load/store alignment specified in opcodes
- [ ] Implement reference type proposal (`funcref`, `externref`)
- [ ] Implement correct trapping and exception handling
- [ ] Implement GC proposal
- [ ] Generate test cases from wasm core spec by parsing `.wast` files
- [ ] Reduce the number of registers needed through better allocation strategies
- [ ] Reduce redundant information clones throughout the codebase
- [ ] Ensure generated code remains compact and efficient

## Supported WebAssembly Features

| Feature | Status | Notes |
|---------|--------|-------|
| MVP (1.0) | âœ… Supported | Core instructions, linear memory, tables |
| Multi-value | âœ… Supported | Multiple return values |
| Sign-extension | âœ… Supported | `i32.extend8_s`, etc. |
| Bulk memory | ðŸ”¶ Partial | `memory.copy`, `memory.fill` pending |
| Reference types | âŒ Not yet | `funcref`, `externref` |
| SIMD | âŒ Not yet | 128-bit vector operations |
| Threads | âŒ Not yet | Atomics, shared memory |
| Exception handling | âŒ Not yet | `try`, `catch`, `throw` |
| GC | âŒ Not yet | Garbage-collected types |

## Performance Considerations

vibewasm prioritizes **compilation speed** over **execution speed**:

**Strengths:**

- Near-instant compilation (single-pass, no optimization)
- Small memory footprint for the compiler itself
- Quick startup time for short-running workloads

**Limitations:**

- No inlining, constant folding, or dead code elimination
- Suboptimal register allocation (greedy, not graph-coloring)
- Frequent register spills for complex expressions
- No loop optimization or vectorization

**Expected performance**: Slightly better than interpretation (1.2-2x), significantly slower than optimized JIT compilers like Cranelift or LLVM (5-20x slower depending on workload).

For performance-critical applications, consider using vibewasm with **pre-optimized WebAssembly modules** generated by wasm-opt or a compiler with its own optimization pipeline.

## Usage Example

```rust
use vibewasm::{Engine, Store, Module, Linker, Value};
use std::sync::Arc;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Create engine with default configuration
    let engine = Arc::new(Engine::default());
    
    // Create a store to hold runtime state
    let mut store = Store::new(engine.clone());
    
    // Parse a WebAssembly module
    let wasm = wat::parse_str(r#"
        (module
            (func (export "add") (param i32 i32) (result i32)
                local.get 0
                local.get 1
                i32.add
            )
        )
    "#)?;
    let module = Module::new(&engine, &wasm)?;
    
    // Create a linker (empty for this example)
    let linker = Linker::new();
    
    // Instantiate the module
    let instance = linker.instantiate(&mut store, &module)?;
    
    // Get and call the exported function
    let add_func = instance.get_func(&store, "add")
        .expect("add function not found");
    
    let result = store.call(add_func, &[Value::I32(40), Value::I32(2)])?;
    assert_eq!(result, vec![Value::I32(42)]);
    
    println!("40 + 2 = {:?}", result[0]);
    Ok(())
}
```

## Building from Source

```bash
# Clone the repository
git clone https://github.com/stevefan1999-personal/sljit-rs
cd sljit-rs

# Build vibewasm
cargo build --release -p vibewasm

# Run tests
cargo test -p vibewasm
```

### Dependencies

- **sljit-rs**: Rust bindings for SLJIT (included in this workspace)
- **wasmparser**: WebAssembly binary parser
- **libffi**: Foreign function interface for host function trampolines
- **wat**: WebAssembly text format parser (dev dependency)

## Roadmap

### Short-term

- [ ] Implement memory bounds checking (configurable)
- [ ] Respect load/store alignment hints from opcodes
- [ ] Complete bulk memory operations
- [ ] Generate tests from wasm core spec test suite

### Medium-term

- [ ] Implement reference types proposal
- [ ] Add proper trap handling with stack traces
- [ ] Support multi-memory proposal
- [ ] Reduce register pressure through better allocation

### Long-term

- [ ] Optional optimization passes (peephole, basic block)
- [ ] SIMD support via SLJIT's SIMD operations
- [ ] GC proposal support
- [ ] AOT compilation mode (serialize compiled code)

## Related Projects

- [wasmtime](https://github.com/bytecodealliance/wasmtime) - Production-quality WebAssembly runtime with Cranelift
- [wasmi](https://github.com/wasmi-labs/wasmi) - WebAssembly interpreter in Rust
- [wasm3](https://github.com/wasm3/wasm3) - Fast WebAssembly interpreter
- [WAMR](https://github.com/bytecodealliance/wasm-micro-runtime) - WebAssembly Micro Runtime

## License

This project is licensed under the same terms as the parent sljit-rs project. See [LICENSE](../LICENSE) for details.

---

<div align="center">

*vibewasm is an experimental project. Use in production at your own risk.*

</div>
